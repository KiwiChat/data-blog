---
title: "Interpreting Generalized Linear Models"
author: Matthias Döring
date: '2018-11-08T15:00:00Z'
draft: true
description: "TODO"
categories:
  - machine-learning
tags:
thumbnail: "/post/machine-learning/linear_models_cover.png"

---



<p>Interpreting generalized linear models (GLM) obtained through <code>glm</code> is similar to <a href="/post/machine-learning/linear_models/">interpreting conventional linear models</a>. Still, there are some differences, which we will discuss here.</p>
<div id="introduction-to-glms" class="section level2">
<h2>Introduction to GLMs</h2>
<p>GLMs enable the use of linear models in cases where the response variable has an error distribution that is non-normal. Each distribution is associated with a specific canonical link function. A link function <span class="math inline">\(g(x)\)</span> fulfills <span class="math inline">\(X \beta = g(\mu)\)</span>. For example, for a Poisson distribution, the canonical link function is <span class="math inline">\(g(\mu) = \text{ln}(\mu)\)</span>. This means that estimates on the original scale can be obtained by taking the inverse of the link function, in this case, the exponential function: <span class="math inline">\(\mu = \exp(X \beta)\)</span>.</p>
</div>
<div id="data-preparation" class="section level2">
<h2>Data preparation</h2>
<p>We will take 70% of samples for training and 30% for testing:</p>
<pre class="r"><code>data(airquality)
ozone &lt;- subset(na.omit(airquality), 
        select = c(&quot;Ozone&quot;, &quot;Solar.R&quot;, &quot;Wind&quot;, &quot;Temp&quot;))
set.seed(123)
N.train &lt;- ceiling(0.7 * nrow(ozone))
N.test &lt;- nrow(ozone) - N.train
trainset &lt;- sample(seq_len(nrow(ozone)), N.train)
testset &lt;- setdiff(seq_len(nrow(ozone)), trainset)</code></pre>
</div>
<div id="training-a-glm" class="section level2">
<h2>Training a GLM</h2>
<p>For investigating the characteristics of GLMs, we will train a model, which assumes that errors are Poisson distributed.</p>
<p>By specifying <code>family = &quot;poisson&quot;</code>, <code>glm</code> automatically selects the appropriate canonical link function, which is the logarithm. More information on possible families and their canonical link functions can be obtained via <code>?family</code>.</p>
<pre class="r"><code>model.pois &lt;- glm(Ozone ~ Solar.R + Temp + Wind, data = ozone, 
                family = &quot;poisson&quot;, subset = trainset)
summary(model.pois)</code></pre>
<pre><code>## 
## Call:
## glm(formula = Ozone ~ Solar.R + Temp + Wind, family = &quot;poisson&quot;, 
##     data = ozone, subset = trainset)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -5.3137  -2.0913  -0.6163   1.7141   6.0361  
## 
## Coefficients:
##              Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept)  0.343052   0.228505   1.501    0.133    
## Solar.R      0.001887   0.000251   7.519 5.52e-14 ***
## Temp         0.045357   0.002491  18.210  &lt; 2e-16 ***
## Wind        -0.072509   0.006728 -10.777  &lt; 2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for poisson family taken to be 1)
## 
##     Null deviance: 1464.87  on 77  degrees of freedom
## Residual deviance:  453.25  on 74  degrees of freedom
## AIC: 863.48
## 
## Number of Fisher Scoring iterations: 4</code></pre>
<p>In terms of the GLM output, there are four main aspects that are different to the output of <code>lm</code>:</p>
<ul>
<li>Deviance (deviance of residuals / null deviance / residual deviance)</li>
<li>Dispersion parameter</li>
<li>AIC</li>
<li>Fisher Scoring iterations</li>
</ul>
<p>Let us investigate these aspects in more detail.</p>
</div>
<div id="deviance-residuals" class="section level2">
<h2>Deviance residuals</h2>
<p>We already know <a href="/post/machine-learning/linear_models/">residuals</a> from the <code>lm</code> function. But what are deviance residuals? In ordinary least-squares, the residual associated with the <span class="math inline">\(i\)</span>-th observation is defined as</p>
<p><span class="math display">\[r_i = y_i - \hat{f}(x_i)\]</span></p>
<p>where <span class="math inline">\(\hat{f}(x) = \beta_0 + x^T \beta\)</span> is the prediction function the fitted model.
For GLMs, there are <a href="https://stackoverflow.com/questions/2531489/understanding-glmresiduals-and-residglm">several ways for specifying residuals</a>. To understand deviance residuals, it is worthwhile to look at the other types of residuals first. For this, we will first make the following definitions:</p>
<pre class="r"><code>expected &lt;- ozone$Ozone[trainset]
g &lt;- family(model.pois)$linkfun # log function
g.inv &lt;- family(model.pois)$linkinv # exp function
estimates.log &lt;- model.pois$linear.predictors # estimates on log scale
estimates &lt;- fitted(model.pois) # estimates on response scale (exponentiated)
all.equal(g.inv(estimates.log), estimates)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>We will discuss four types of residuals: response residuals, working residuals, Pearson residuals, and, finally, deviance residuals. There is also another type of residual called <em>partial residual</em>, which is formed by determining residuals from models where individual features are excluded. This residual is not discussed here.</p>
<div id="response-residuals" class="section level3">
<h3>Response residuals</h3>
<p>For <code>type = &quot;response&quot;</code>, the <em>conventional</em> residual on the response level is computed, that is,
<span class="math display">\[r_i = y_i - \hat{f}(x_i)\]</span>
This means that the fitted residuals are transformed by taking the inverse of the link function:</p>
<pre class="r"><code># type = &quot;response&quot;
res.response1 &lt;- residuals(model.pois, type = &quot;response&quot;)
# note: fitted() returns the exponentiated estimates
res.response2 &lt;- expected - estimates
all.equal(res.response1, res.response2)</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="working-residuals" class="section level3">
<h3>Working residuals</h3>
<p>For <code>type = &quot;working&quot;</code>, the <em>response residuals</em> are normalized by the estimates:</p>
<p><span class="math display">\[r_i = \frac{y_i - \hat{f}(x_i)}{\hat{f}(x_i)}\]</span></p>
<pre class="r"><code># type = &quot;working&quot;
res.working1 &lt;- residuals(model.pois, type=&quot;working&quot;)
res.working2 &lt;- (expected - estimates) / estimates
all.equal(res.working1, res.working2)</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="pearson-residuals" class="section level3">
<h3>Pearson residuals</h3>
<p>For <code>type = &quot;pearson&quot;</code>, the Pearson residuals are computed. They are defined as
<span class="math display">\[r_i = \frac{y_i - \hat{f}(x_i)}{\sqrt{\hat{f}(x_i)}}\]</span></p>
<pre class="r"><code># type = &quot;pearson&quot;
res.pearson1 &lt;- residuals(model.pois, type=&quot;pearson&quot;)
res.pearson2 &lt;- (expected - estimates) / sqrt(estimates)
all.equal(res.pearson1, res.pearson2)</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="deviance-residuals-1" class="section level3">
<h3>Deviance residuals</h3>
<p>Deviance residuals are defined by considering the deviance. The deviance of a model is defined by</p>
<p><span class="math display">\[{D(y,{\hat {\mu }})=2{\Big (}\log {\big (}p(y\mid {\hat {\theta }}_{s}){\big )}-\log {\big (}p(y\mid {\hat {\theta }}_{0}){\big )}{\Big )}.\,}\]</span></p>
<p>where</p>
<ul>
<li><span class="math inline">\(y\)</span> is the outcome</li>
<li><span class="math inline">\(\hat{\mu}\)</span> is the estimate of the model</li>
<li><span class="math inline">\(\hat{\theta}_s\)</span> and <span class="math inline">\(\hat{\theta}_0\)</span> are the parameters of the fitted <em>saturated</em> and <em>proposed models</em>, respectively</li>
<li><span class="math inline">\(p(y | \theta)\)</span> is the likelihood of data given the model</li>
</ul>
<p>So, what is a saturated model? A saturated model has as many parameters as it has training points, that is, <span class="math inline">\(p = n\)</span>. The proposed model can be any other type of model. For the residual deviance, this is the model that you have trained.</p>
<p>This means that the deviance indicates the extent to which the likelihood of the saturated model exceeds the likelihood of the proposed model. If the proposed model has a good fit, the deviance will be small. If the proposed model has a bad fit, the deviance will be high. For example, for the Poisson model, the deviance is</p>
<p><span class="math display">\[D = 2 \cdot \sum_{i = 1}^n y_i \cdot \log \left(\frac{y_i}{\hat{\mu}_i}\right) − (y_i − \hat{\mu}_i)\,.\]</span></p>
<p>In R, the deviance residuals represent the contributions of individual samples to the deviance <span class="math inline">\(D\)</span>. More specifically, they are defined as the signed <a href="https://www.youtube.com/watch?v=JC56jS2gVUE">square roots of the unit deviances</a>. Thus, the deviance residuals are analogous to the conventional residuals: when they are squared, we obtain the sum of squares that we use for assessing the fit of the model. However, while the sum of squares is the residual sum of
squares for linear models, for GLMs, this is the deviance.</p>
<p>How does such a deviance look like in practice? For example, for the Poisson distribution, the deviance residuals are defined as:</p>
<p><span class="math display">\[r_i = \text{sgn}(y - \hat{\mu}_i) \cdot \sqrt{2 \cdot y_i \cdot \log \left(\frac{y_i}{\hat{\mu}_i}\right) − (y_i − \hat{\mu}_i)}\,.\]</span></p>
<p>Let us verify this in R:</p>
<pre class="r"><code># type = &quot;deviance&quot;
res.dev1 &lt;- residuals(model.pois, type = &quot;deviance&quot;)
res.dev2 &lt;- residuals(model.pois)
poisson.dev &lt;- function (y, mu) 
    # unit deviance
    2 * (y * log(ifelse(y == 0, 1, y/mu)) - (y - mu))
res.dev3 &lt;- sqrt(poisson.dev(expected, estimates)) * 
        ifelse(expected &gt; estimates, 1, -1)
all.equal(res.dev1, res.dev2, res.dev3)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Note that, for ordinary least-squares models, the <a href="http://people.stat.sfu.ca/~raltman/stat402/402L11.pdf">deviance residual is identical to the conventional residual</a>.</p>
<p>Now, how do these values look for our model?</p>
<pre class="r"><code>summary(residuals(model.pois))</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## -5.3137 -2.0913 -0.6163 -0.1642  1.7141  6.0361</code></pre>
<p>Since the median deviance residual is close to zero, this means that our model is not biased in one direction (i.e. the out come is neither over- nor underestimated).</p>
</div>
</div>
<div id="null-and-residual-deviance" class="section level2">
<h2>Null and residual deviance</h2>
<p>Since we have already introduced the deviance, <a href="https://stats.stackexchange.com/questions/108995/interpreting-residual-and-null-deviance-in-glm-r">understanding the null and residual deviance</a> is not a challenge anymore. Remember the definition of the deviance?</p>
<p><span class="math display">\[{D(y,{\hat {\mu }})=2{\Big (}\log {\big (}p(y\mid {\hat {\theta }}_{s}){\big )}-\log {\big (}p(y\mid {\hat {\theta }}_{0}){\big )}{\Big )}.\,}\]</span></p>
<p>If, <span class="math inline">\(\theta_0\)</span> refers to the null model (i.e. an intercept-only model), this gives rise to the <em>null deviance</em>.
If, however, <span class="math inline">\(\theta_0\)</span> refers to the trained model, this gives rise to the <em>residual deviance</em>. So, how can we interpret these two quantities?</p>
<ul>
<li>Null deviance: A low null deviance implies that the data can be modeled well merely using the intercept. If the null deviance is low, you should consider using few features for modeling the data.</li>
<li>Residual deviance: A low residual deviance implies that the model you have trained is appropriate. Congratulations!</li>
</ul>
<p>How does this look for our model?</p>
<pre class="r"><code>paste0(c(&quot;Null deviance: &quot;, &quot;Residual deviance: &quot;),
       round(c(model.pois$null.deviance, deviance(model.pois)), 2))</code></pre>
<pre><code>## [1] &quot;Null deviance: 1464.87&quot;    &quot;Residual deviance: 453.25&quot;</code></pre>
<p>These results are somehow reassuring. First, the null deviance is high, which means it makes sense to use more than a single parameter. Second, the residual deviance is relatively low, which indicates that the log likelihood of our model is close to the log likelihood of the saturated model. However, for a well-fitting model, the residual deviance should be close to the degrees of freedom (74), which is not the case. For example, this could be a result of
overdispersion where the variation is greater than predicted by the model. This can happen for a Poisson model, if the actual variance exceeds the mean, although <span class="math inline">\(Var(Y) = \mu\)</span> is assumed by the model.</p>
</div>
<div id="dispersion-parameter" class="section level2">
<h2>Dispersion parameter</h2>
<p>To understand the dispersion parameter, we have to understand the concept of dispersion first. Dispersion (variability/scatter/spread) simply indicates whether a distribution is wide or narrow.</p>
<p>For likelihood-based model, the dispersion parameter is always fixed to 1. It is adjusted only for methods that are based on quasi-likelihood estimation such as <code>quasipoisson</code> or <code>quasibinomial</code>. These methods can deal with overdispersion.</p>
</div>
<div id="aic" class="section level2">
<h2>AIC</h2>
</div>
<div id="fisher-scoring-iterations" class="section level2">
<h2>Fisher scoring iterations</h2>
</div>
