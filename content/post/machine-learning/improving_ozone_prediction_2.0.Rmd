---
title: "Improving Ozone Prediction 2.0"
author: Matthias DÃ¶ring
downloadRmd: true
draft: true
date: '2018-12-09T15:00:00Z'
description: ""
categories:
  - machine-learning
tags:
    - analysis
    - linear model
    - supervised learning
    - R
thumbnail: "/post/machine-learning/improving_ozone_prediction_cover.png"
---
Recently, I have worked on finding a suitable linear model for ozone prediction](/post/machine-learning/improving_ozone_prediction/). At that time, I did not take the longitudinal nature of the measurements into account but instead assume that all the measurements are independent of one another. However, a more reasonable assumption is that, when the ozone level was high the day before, it is likely going to be high the following day.

## Exploring the temporal nature of the data

Let us load the ozone data set and divide it into test and training set:

```{r}
data(airquality)
ozone <- subset(na.omit(airquality))
set.seed(123)
N.train <- ceiling(0.7 * nrow(ozone))
N.test <- nrow(ozone) - N.train
trainset <- sample(seq_len(nrow(ozone)), N.train)
testset <- setdiff(seq_len(nrow(ozone)), trainset)
```

We are interested in finding out whether the observed value of ozone depends on the previous measurements, that is, whether

\[Pr(Y = y | X = x^1, \ldots, x^t) \neq Pr(Y = y | X = x)\]

For this purpose, we will create a new column in the ozone data set, which reflects the relative point in time:

```{r}
year <- 1973
months <- unique(ozone$Month)
months <- c(months, max(months) + 1)
dates <- sapply(paste0(year, "-", months, "-", "01"), as.Date)
days.per.month <- as.numeric(diff(dates))
names(days.per.month) <- unique(ozone$Month)
t <- rep(NA, nrow(ozone))
for (i in seq_len(nrow(ozone))) {
    month.days <- days.per.month[as.character(ozone$Month[i])]
    offset <- ozone$Month[i] - min(ozone$Month)
    days.before <- 0
    if (offset != 0) {
        days.before <- sum(days.per.month[1:offset])
    }
    t[i] <- ozone$Day[i] + days.before

}
ozone <- cbind(ozone, "t" = t)
```

Let us now plot the time trend of ozone:

```{r}
library(ggplot2)
ggplot(ozone, aes(x = t, y = Ozone)) + geom_line() +
        geom_point()
```

Idea: 
* use kNN on validation set to find number of neighbors to consider to predict ozone level (neighbors according to t only)
* then, in model use this encoding
