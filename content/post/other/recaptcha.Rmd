---
title: "Staticman: An Alternative to Disqus for Comments on Static Sites"
author: Matthias DÃ¶ring
date: '2018-11-01'
lastmod: '2018-11-10'
downloadRmd: false
description: "Staticman is an API that can be used to implement a commenting system for static websites. Here, I discuss how I managed to set up my own instance of the Staticman API and how it can be integrated into a Hugo site."
thumbnail: "/post/other/staticman_comments_avatar.png"
thumbnailsrc: "Figure: staticman.net"
categories:
  - other
tags:
  - Hugo
---
As you probably know, I'm a big fan of [Staticman's approach](https://www.datascienceblog.net/post/other/staticman_comments/) to enable dynamic content on static web sites. However, when I introduced comments on this blog, things quickly got out of hand: Each day, I would receceive roughly five spam comments that were posted by bots. Since I currently manually approve each comment, I decided that I could no longer sift through all the pull requests on the blog that were generated by Staticman:

' pull_requests_comments.png'

So, I decided to install a standard solution for dealing with spam - Google's reCAPTCHA approach. However, things didn't go as smoothly as I expected. So, what you will learn is, first, how not to set up a reCAPTCHA system, and, second, how to do it properly.

## Introduction to ReCAPTCHA

ReCAPTCHA aims at differentiating between human users and bots. It is most often used in the context of forms, which are intended as a form of communication between human users. However, there are also people that exploit forms for the purpose of spamming. These people don't spam form fields by hand but instead use automated approaches, so called bots, that automatically fill in the forms and then submit it. Bots are great for spammers but a real nuisance for web site owners like me who would like to offer a nice platform for people to hang out where one is not constantly advised to buy ominous drugs or invest in bitcoin.

When you register your site with ReCAPTCHA, you will receive two tokens. A public site key, which is used for client-side identification and a secret token, which is intended for server-side verification. The approach that ReCAPTCHA uses to identify bots evolved over the years:

TODO: images

* ReCAPTCHA v1: Users are presented by visually distorted words and have to transcribe them. Usability was low because it was tedious to get the CAPTCHA right. Moreover, smart bots could easily overcome the challenge.
* ReCAPTCHA v2: Users are presented by a checkmark. After pressing the checkmark, the system assesses whether the interaction was natural or not. If it wasn't, then the user has to select the appropriate elements from a grid. ReCAPTCHA v2 greatly improved the user experience over v1 because humans usually just have to check the box and do not have to solve a riddle.
* ReCAPTCHA v3: This version is a revolution of the CAPTCHA system because there is no challenge that is posed to the user. Instead, Google relies solely on their vast amount of user data, which is analyzed using machine intelligence tools, in order to calculate a score ranging from 0 (definitely a bot) to 1 (definitely human). With this, user experience is as smooth as possible. Moreover, website owners can regulate the stringency of spam protection by selecting an appropriate cutoff on the computed score.

## How not to Implement ReCAPTCHA

Now that we share a common understanding about ReCAPTCHA, let's talk about how not to implement ReCAPTCHA. To solve my spam problems, I tried to implement a solution using ReCAPTCHA v2. After [registering my blog at ReCAPTCHA](https://www.google.com/recaptcha/), I stumbled upon a [Edouardo Bouca's GitHub repo](https://github.com/eduardoboucas/staticman-recaptcha) where he explains how Staticman can be setup using ReCAPTCHA v2. At this point, I thought all my problems would easily be solved. 

Unfortunately, I had problems getting this approach to work. In fact, I felt so bad, I just tried it again in [this change](https://github.com/rbind/data-blog/commit/27da769ea29dff422d41514f62cf4f45c38696ed). Because I think I didn't make a configurational mistake, I guess it could be because I'm hosting my own instance of Staticman, which may not be supporting ReCAPTCHA yet. 

Anyways, I started looking for solutions than the ReCAPTCHA verification that is offered by Staticman itself. So, the next thing I tried was to simply do the verification of the ReCAPTCHA by myself. In fact, I was bold enough to verify the ReCAPTCHA in the client itself. What did I do?

I implemented a Javascript function to validate the CAPTCHA like this: 

```javascript
function validateRecaptcha() {
    var response = grecaptcha.getResponse();
    if (response.length === 0) {
        console.log("recaptcha not verified")
        return false;
    } else {
        alert("recaptcha validated");
        return true;
    }
}
```

Here, the assumption was that there should only be a response if the CAPTCHA was solved successfully. Based on this idea, I integrated this function into the form submission like this:

```javascript
<form class="post-comment" method="POST" action="{{ .Site.Params.staticman.comments_api }}" onsubmit="return validateRecaptcha();">
```

By using the onsubmit parameter, the form's action will only trigger if the onsubmit function returns true (i.e. the validation was successful). Sounds good to you? Well, that's what I thought too and I was happy with the solution ... until I found out that it doesn't work because I still received a ton of spam.

So, why didn't the approach work? If you look at the verification code, you can quickly realize that it never mentions the secret ReCAPTCHA token. It also shouldn't because the secret token is intended should only be used on the server-side so it remains unknown to the client. But this is a problem: when you're verifying a ReCAPTCHA only on the client-side, the client can create an arbitrary response. In my case, the client could simply overwrite the `validateRecaptcha()` function such that it always returns true - making every bot pass the ReCAPTCHA challenge. 

So, if you learn only one lesson from this post, remember that you should never verify data on the client-side.

## How to Implement ReCAPTCHA the Right Way

After failing to get ReCAPTCHA working for such a long time, I was close to giving up. However, I was even more frustrated about not being able to get something simple like this to work, which is why I made another attempt to get it right.

What became clear to me was that I would need to have a service for verifying the ReCAPTCHA response on the server side. Since I'm hosting a static site, I don't have a server at my disposal. Luckily, nowadays, everything is hosted in the cloud anyways, so it's relatively easy to set up some serverless code for verifying the ReCAPTCHA response. In the following, I will show you how to setup a service for verifying ReCAPTCHA responses on AWS.

When I investigated ReCAPTCHA investigation using AWS, [I found some lambda code from lighthacker in the public repository](https://recaptcha-verify-public-bucket.s3.amazonaws.com/recaptcha-verify/1.0.0/2483c78bf137bc292cc27099f8064231). This code is based on Node.js and utilizes Express to offer a REST API whose endpoint is `verify`, which takes the token that is generated by ReCAPTCHA as a parameter. The service then performs the verification [through Google's siteverify API](https://developers.google.com/recaptcha/docs/verify).

Although the implementation sets `Access-Control-Allow-Origin` to an asterisk, I still encountered problems with [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) when I copied the AWS lambda code and deployed it. I tried many things such as adapting the CORS capabilities in the AWS API gateway but nothing worked, so I decided to redeploy the code rather than simply copying the application's setup in AWS. For this purpose, I performed the following steps:

* [Download the Node.js project](https://recaptcha-verify-public-bucket.s3.amazonaws.com/recaptcha-verify/1.0.0/2483c78bf137bc292cc27099f8064231)
* Install the dependencies using `npm install`
* Verify the implementation (including CORS) by running the API using `node app.js` and posting requests via Postman

To do the AWS setup on the command line, I used the serverless approach described in [Marc Logemann's Medium post](https://medium.com/aws-factory/recaptcha-form-with-an-amazon-aws-serverless-backend-environment-809cdb788424). I first installed serverless via `npm install -g serverless` and then created a severless.yml file with the following content:

```
service: recaptcha-less
provider:
  name: aws
  runtime: nodejs8.10
  stage: dev
  region: us-east-1
  memorySize: 128
functions:
  app:
    handler: app/index.handler
    events: 
      - http: 
          path: /
          method: ANY
          cors: true

```

Then, I just ran `serverless config credentials -p aws -k {personalKey} -s {secretToken}`, followed by `serverless deploy` in order to configure the deployment on AWS. After the API was running on AWS, I implemented a client-side function for interacting with the API:

```javascript
async function validateRecaptcha() {
    // read hidden form fields
    var token = document.getElementById("gRecaptchaResponse").value;
    var verify_api = document.getElementById("verify_url").value;
    // call verification API using captcha token
    const response = await fetch(verify_api+token, {
        headers: {
             'Accept': 'application/json',
             'Content-Type': 'application/json'
        },
        mode: 'cors',
        method: 'GET'
    })
    var result = await response.json();
    return (result.success == "true" && result.score >= 0.6);
}
```

The function only returns true if the server-side ReCAPTCHA verification did not yield an error and led to a score of 0.6 or greater.

As of now, I'm very happy with this solution because the amount of spam I receive has been drastically reduced. However, [ReCAPTCHA v3 is also a bit disturbing](https://medium.com/@jsoverson/thoughts-on-recaptcha-v3-e837d4a0a63): if your score is too low, you do not even get a chance to prove that you're human. I'd prefer an invisible CAPTCHA where you can still prove your humanity rather than being simply blocked but it seems that something like this is currently not available. So, if you are willing to lose some control over an increase in useability, ReCAPTCHA v3 is the way to go.

